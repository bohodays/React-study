## 05. 리액트 클래스 컴포넌트

<br>

### 5.1 함수 컴포넌트와 클래스 컴포넌트

- 함수 컴포넌트는 클래스 컴포넌트보다 더 간결하고 렌더링 성능도 좋아서 최근에 많이 사용되고 있다. 그러나 클래스 컴포넌트도 반드시 알아두는 것이 좋다. 그 이유는 함수 컴포넌트에서는 지원하지 않는 다양한 생명주기 이벤트 훅들이 제공되기 때문이다.

<br>

### 5.2 생명주기 메서드

- 생명주기 메서드(life cycle method)는 리액트 클래스 컴포넌트에서만 사용할 수 있으며, 함수 컴포넌트에서는 다음 장에서 다룰 useEffect( )라는 리액트 훅을 이용해 유사한 기능을 구현할 수 있다.
- 생명주기 메서드는 다음 세 가지의 경우에서 자동으로 호출되는 메서드를 말한다.
  - 컴포넌트가 마운트(mounting)될 때
    - 리액트 컴포넌트가 애플리케이션의 컴포넌트 트리에 추가되어 브라우저 화면에 나타날 때의 단계별 생명주기 메서드
  - 컴포넌트가 업데이트(updating)될 때
    - 리액트 컴포넌트의 상태, 속성이 변경되어 브라우저 화면이 갱신될 때의 단계별 생명주기 메서드
  - 컴포넌트가 언마운트(unmounting)될 때
    - 리액트 컴포넌트가 애플리케이션의 컴포넌트 트리에서 제거되어 브라우저 화면에 사라질 때의 생명주기 메서드

<br>

### 5.2.1 컴포넌트가 마운트될 때

- constructor(생성자)
  - 컴포넌트가 생성될 때 호출되는 생명주기 메서드이다. 생성자에서는 반드시 super(props)를 호출해야 하며, 그렇지 않으면 컴포넌트에서 속성(props)을 사용할 수 없으므로 에러가 발생한다. 생성자는 this.state에 객체를 할당하여 컴포넌트의 상태(state)를 초기화하기 위해 작성한다. 따라서 생성자 내부에서는 상태를 초기화만 할 수 있으며 this.setState( ) 메서드를 이용해 상태를 변경해서는 안된다. 상태를 초기화할 일이 없다면 생성자를 작성하지 않아도 된다.
- getDerivedStateFromProps 정적 메서드
  - 이 생명주기 메서드는 컴포넌트의 상태가 부모 컴포넌트로부터 전달받은 속성에 의해 달라지는 경우에 사용한다. 이 메서드는 정적 메서드이므로 반드시 static 키워드를 지정해야하며, props와 state 두 개의 인자를 전달받는다. props는 전달받은 속성 객체이며 state는 컴포넌트의 기존 상태이다. 그리고 props를 이용해 새로운 상태를 만들어서 리턴한다. 일반적으로 전달받은 속성을 그대로 사용하기 때문에 이 생명주기 메서드를 사용할 일은 그다지 많지 않다.
- render 메서드
  - 컴포넌트를 가상 DOM으로 렌더링하는 메서드이다. 상태와 속성을 이용해 리액트 엘리먼트 등으로 렌더링하며, 함수 컴포넌트의 리턴문 부분에 해당한다. 이 함수는 상태와 속성이 변경되지 않았다면 같은 결과를 리턴해야 한다.
- componentDidMount 메서드
  - 컴포넌트의 마운트가 완료되고 나서 브라우저 DOM의 트리에까지 반영이 된 후 호출되는 메서드이다. 따라서 브라우저 DOM이 완성된 후에 실행해야 하는 초기화 작업을 하기에 적합하다. 예를 들어 HTTP로 백엔드 API를 호출하여 그 결과를 받아서 this.setState( ) 메서드로 상태를 변경하고 브라우저 DOM에 출력해야 하는 초기화 작업이 필요하다면 이 생명주기 메서드를 이용할 수 있다.

<br>

### 5.2.2 컴포넌트가 업데이트될 때

- getDerivedStateFromProps 정적 메서드
  - 컴포넌트가 마운트될 때와 같다.
- shouldComponentUpdate 메서드
  - 렌더링 성능을 최적화할 때 자주 사용한다. 이 메서드에 전달되는 인자는 새롭게 전달된 속성(nextProps)과 상태(nextState)이며, 리턴값은 boolean 값이다. 이 메서드의 리턴값이 true면 다음 단계의 생명주기 메서드(render)가 호출되며, false면 다음 단계의 생명주기로 넘어가지 않는다. 이 메서드에서는 새롭게 전달된 속성과 상태를 기존의 속성(this.props)과 상태(this.state)와 비교하여 다시 렌더링할지를 결정한다.
  - 메서드에서 깊은 비교를 수행하면 많은 시스템 리소스가 사용되므로 렌더링 성능 최적화가 힘들어진다. 이 문제를 해결하기 위해 immer 라이브러리나 전개 연산자를 이용해 불변성을 가지는 변경 작업을 수행해야 한다.
- getSnapshotBeforeUpdate 메서드
  - 이 메서드가 실행되는 시점은 render( ) 메서드가 호출되어 가상 DOM으로의 쓰기 작업이 완료된 후, 브라우저 DOM에 업데이트되기 전이다. 이 메서드를 많이 사용하지는 않지만, 변경 전의 DOM 상태 정보를 획득하여 스냅샷 값으로 리턴해서 componentDidUpdate( ) 메서드의 세 번째 인자(snapshot)로 받아낼 때 이용한다.
- componentDidUpdate 메서드
  - 이 메서드가 실행되는 시점은 브라우저 DOM까지 업데이트가 완료된 후이다. 이 메서드는 컴포넌트가 업데이트되고 DOM을 변경하고자 할 때 사용한다. 현재의 속성(this.props)과 상태(this.state)을 이전의 속성, 상태와 비교하여 차이가 있다면 외부 API를 요청하는 등의 작업을 수행하도록 활용할 수 있다. getSnapshotBeforeUpdate( ) 메서드에서 리턴한 값은 이 메서드의 세 번째 인자인 snapshot으로 전달된다. 따라서 getSnapshotBeforeUpdate( ) 메서드와 componentDidUpdate( ) 메서드는 함께 사용되는 경우가 많다.

<br>

### 5.2.3 컴포넌트가 언마운트될 때

- componentWillUnmount 메서드
  - 이 메서드는 컴포넌트가 애플리케이션의 컴포넌트 트리에서 삭제되기 직전에 실행되고, 주로 componentDidMount 생명주기 메서드와 짝을 이루어 사용된다. 예를 들어, 웹소켓을 이용해 서버에 연결하는 경우, 컴포넌트가 마운트될 때 componentDidMount 메서드에서 외부 서버나 리소스에 연결하면 컴포넌트가 언마운트될 때는 componentWillUnmount 메서드에서 서버와의 연결을 해제한다. 외부 리소스에 연결한 경우네느 반드시 componenetWillUnmout에서 깨끗하게 연결을 해제해야 한다. 그렇지 않으면 메모리 누수(memory leak)가 발생할 수 있고, 불필요한 외부 리소스 연결이 남아있게 된다.

<br>

### 5.3 가상 DOM과 조정

<br>

### 5.3.1 가상 DOM과 브라우저 DOM

- 가상 DOM은 브라우저 DOM의 트리 구조를 그대로 브라우저 메모리상에 구현한 DOM 트리 객체다. 가상 DOM을 사용하는 이유는 브라우저 DOM을 조작하는 것은 느리기 때문이다. 정확하게는 자바스크립트 언어로 브라우저 DOM을 조작하는 코드를 실행하는 것은 느리지 않지만, 화면을 브라우저에 다시 그려내는 작업이 느리다.
- 브라우저의 화면은 reflow와 repaint의 두 단계를 거쳐서 다시 렌더링된다. reflow는 relayout이라고도 부르는데, 렌더링할 DOM 트리를 새롭게 만들고 HTML 요소들의 위치와 크기를 계산해 배치하는 단계입니다. reflow가 완료되고 나면 HTML 요소에 스타일 요소를 입히고 UI를 그려내는 repaint 단계가 실행된다.
- 브라우저 DOM을 조작할 때마다 reflow, repaint 단계가 실행되면서 리소스를 소모하고, 이로 인해 렌더링 성능이 저하되기 때문에 매번 브라우저 DOM을 조작하는 것은 바람직하지 않다. 이 문제점을 해결하기 위해 가상 DOM을 사용하는 것이다.
- 가상 DOM을 이용하면 가상 DOM 수준에서 이전 버전과 현재 버전의 DOM 트리를 비교해서 차이가 나는 부분만을 브라우저 DOM에 업데이트하기 때문에 브라우저 DOM 수준에서 불필요한 reflow, repaint 작업을 줄일 수 있다. 이러한 과정을 조정(reconciliation)이라고 한다.

<br>

### 5.3.2 key 특성

- key 특성은 컴포넌트 내부에서 반복적으로 자식 컴포넌트와 요소를 렌더링할 때 지정한다. 대부분의 반복적인 리스트 항목은 그대로인데 일부 항목들이 추가, 삭제, 변경되는 경우에 변경 사항을 추적하는 것은 쉽지 않다. 이러한 리스트 항목의 변경을 추적하기 위해 key 특성을 사용한다.
- key 특성은 배열 데이터(상태, 속성)를 이용해 반복적인 렌더링을 할 때 각 항목의 고유 키가 된다. key를 지정하지 않으면 배열 데이터의 어떤 값이 어느 요소에 렌더링됐는지를 추적할 방법이 없으므로 리스트 전체를 다시 렌더링해야 한다. 하지만 key 특성을 지정하면 배열 데이터의 어떤 값이 어느 요소에 렌더링됐는지를 key를 비교해서 추적할 수 있다. 따라서 리스트 전체를 다시 렌더링하지 않아도 되므로 조정 작업을 효율적으로 수행할 수 있다.

<br>

### 5.3.3 생명주기 메서드를 이용한 렌더링 최적화

- 리액트 클래스 컴포넌트에서 shouldComponentUpdate 생명주기 메서드는 컴포넌트의 render( ) 메서드가 호출되기 전에 실행되는 메서드이다. 이 메서드에서 리턴값이 false이면 이 메서드 이후의 생명주기 메서드를 실행하지 않으므로 render( ), componentDidUpdate( ) 메서드가 모두 실행되지 않는다. render( ) 메서드를 실행하지 않으므로 가상 DOM에 대한 다시 렌더링을 실행하지 않기 때문에, 가상 DOM의 쓰기 작업도 줄이고 브라우저 DOM의 업데이트도 최적화할 수 있다.
- shouldComponentUpdate( ) 메서드에서 렌더링 여부를 빠르게 결정하려면 불변성을 가진 상태변경이 필요하다. 상태 트리의 끝단에서 값을 변경했을 때 끝단으로부터 최상위로 거슬러 올라가는 경로상의 객체를 모두 새로운 객체로 변경한다. 따라서 이전 버전의 객체 트리와 현재 버전의 객체 트리를 비교하는 작업은 객체의 메모리 주소가 같은지만을 비교하면 되는 것이다. 이러한 비교를 얕은 비교(shallow compare)라고 부른다. 따라서 리액트 애플리케이션의 렌더링 성능을 최적화하기 위해 가장 기본적으로 필요한 요구 사항은 불변성을 가지도록 상태를 변경하는 것이다.

<br>

### 정리

- 함수 컴포넌트를 더 많이 사용하지만 클래스 컴포넌트는 다양한 생명주기 메서드를 사용할 수 있으므로 익혀두는 것이 좋다.
- 생명주기 메서드의 쓰임은 컴포넌트가 마운트될 때, 컴포넌트의 상태나 속성이 업데이트될 때, 컴퓨터가 언마운트될 때로 구분할 수 있다. 그리고 컴포넌트 내부에서 에러가 발생했을 때는 componentDidCatch 생명주기 메서드를 이용해 에러 처리를 수행한다.
- 특히 컴포넌트가 마운트될 때와 언마운트될 때는 외부 리소스를 연결하고 해제하는 코드를 꼭 작성해야 한다. 그렇지 않으면 메모리 누수나 내부에러가 발생할 수 있다.
- ShouldComponentUpdate 생명주기 메서드와 PureComponent를 활용하고, 불변성을 가지는 상태 변경을 수행하면 어렵지 않게 렌더링 성능을 최적화할 수 있다.
