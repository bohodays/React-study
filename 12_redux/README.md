## 12. 리덕스를 이용한 상태 관리

<br>

### 12.1 플럭스 아키텍처와 리덕스

- 플럭스(flux) 아키텍처는 "대규모 애플리케이션에서 일관된 데이터 관리를 손쉽게 하기 위해 만들어진 단방향 데이터 처리 과정을 가지는 아키텍처"이다.
- 플럭스 아키텍처 개요도 (p.421)
- 플럭스 아키텍처의 가장 중요한 특징은 단방향 데이터 흐름이라는 점이다.
- 전체 처리 과정
  1. 뷰 컴포넌트(리액트 컴포넌트)에서 이벤트가 발생하면 이벤트 핸들러에 의해 액션 생성자(ActionCreator)가 호출된다.
  2. 액션 생성자는 외부 API 호출과 같은 부작용(side effect) 처리를 수행하고 수행 결과를 액션(action)이라는 일종의 객체 형태의 메시지를 생성하여 디스패처(dispatcher)에 전달한다. 액션의 형식은 다음과 유사한 형태다.
     - 예시: {type: "addTodo", payload: {todo: "강변 달리기", desc:"출근 전 30분 뛰기"}}
  3. 디스패처는 액션을 스토어로 전달합니다. 스토어는 액션 정보를 이용해 지정된 상태 변경 작업을 수행한다.
  4. 상태가 변경되면 각 스토어와 연결(binding)된 컴포넌트의 UI가 갱신된다.

<br>

- 리덕스 : 자바스크립트 애플리케이션을 위한 예측 가능한 상태 관리 컨테이너이며, UI 상태와 데이터 상태를 관리하기 위한 효과적인 도구이다. 리덕스는 리액트뿐만 아니라 모든 자바스크립트 애플리케이션에서 이용할 수 있다.
- 리덕스는 플럭스 아키텍처를 이용했지만 플럭스 아키텍처를 발전시키면서 복잡성을 줄일 수 있도록 설계됐다. 그 결과 플럭스의 기능과 더불어 핫 리로딩(hot reloading), 시간 여행 디버깅(time travel debugging)과 같은 기능을 제공한다.
- 기존 플럭스 아키텍처에서는 스토어가 상태와 상태 변경 로직을 포함하지만 리덕스의 스토어는 상태만을 가지고, 상태 변경의 기능을 리듀서(Reducer)라는 요소로 분리했다. 이 결과 상태 변경 로직이 개발 중에 변경되더라도 상태를 유지시킬 수 있다. 이것을 핫 리로딩 기능이라고 하며 디버깅할 때 유용하다.
- 리덕스의 또 한 가지 특징은 리듀서를 이용해 상태를 변경할 때 기존 상태 객체를 변경하지 않고 새로운 상태 객체를 생성한다는 점이다. 리덕스의 불변성을 가지는 상태 변경은 시간 흐름에 따라 상태의 이력(history)을 남긴다. 상태 변경 이력은 시간 흐름에 따라 상태가 어떻게 변경됐는지를 손쉽게 추적(trace)할 수 있게 해준다. 그리고 애플리케이션 개발 중에 과거의 어느 한 시점의 상태로 돌아가서 다시 기능을 확인할 수 있어 디버깅할 때 아주 유용하다. 이러한 디버깅 기능을 시간 여행 디버깅이라고 한다.

<br>

- 리덕스 상세 보기
  1. 스토어의 상태와 액션 생성자를 이용한 디스패치 기능의 함수가 주입된 뷰 컴포넌트(리액트 컴포넌트)에서 이벤트가 발생한다.
  2. 뷰 컴포넌트의 이벤트 핸들러는 속성으로 주입된 함수가 호출되며, 이때 action(객체, 메시지)을 만들어서 스토어로 전달(dispatch)한다. 액션의 형태는 플럭스 아키텍처에서 사용하던 것고 유사하다.
     - 예시: {type: "addTodo", payload: {todo: "강변 달리기", desc:"출근 전 30분 뛰기"}}
  3. 스토어는 전달받은 액션과 자신의 상태를 리듀서 함수의 인자로 전달한다. 리듀서는 다음과 같은 형식의 함수다.
     - 리듀서 형식 : (state, action) => { ... }
  4. 리듀서는 인자로 전달받은 상태(state)는 변경하지 않고, action을 이용해 새로운 상태를 만든 뒤 리턴한다.
  5. 스토어는 리듀서가 리턴한 상태를 새로운 상태로 설정한다. 스토어의 새로운 상태는 뷰 컴포넌트에 연결(binding)되어 있으므로 화면이 새롭게 렌더링된다.
- 리듀서는 여러 개 만들 수 있다. 리듀서는 상태 변경 로직을 포함하면서 더불어 스토어가 가지는 초기 상태를 전달해주는 역할을 한다. 복잡한 상태 트리인 경우는 계층적으로 리듀서를 구성하고, 상위 리듀서는 하위 리듀서가 리턴하는 하위 상태를 받아서 전체 상태를 구성하여 스토어에게 전달해준다.
- 또한 리듀서는 순수 함수(pure function)여야 한다. 순수 함수의 특징은 다음과 같다
  - 입력 인자가 동일하면 리턴 값도 같아야 한다.
  - 함수에 전달된 인자는 불변성으로 여겨지므로 인자를 변경할 수 없다.
  - 부작용(side effect)이 없어야 한다. 부작용은 함수 외부의 값을 이용하거나 함수 외부의 값이나 기능에 영향을 주는 효과를 말한다.
- 가장 대표적인 순수 함수의 예를 들면 다음과 같다.

  ```javascript
  const nums = [10, 20, 30, 40];

  // reduce 메서드에 전달되는 함수를 리듀서라고 한다.
  const sumNumbers = nums.reduce((sum, num) => {
    return sum + num;
  });

  console.log(sumNumbers);

  // 리덕스의 리듀서 함수
  (state, action) => {
    ...
    return newState;
  }
  ```

<br>

- 액션 → 미들웨어 → 리듀서 → 스토어

<br>

- 리덕스 미들웨어를 사용하면 디스패치 된 다음, 리듀서에서 해당 액션을 받아와서 업데이트하기 전에 추가적인 작업을 할 수 있다.
  - 특저 조건에 따라 액션이 무시되게 만들 수 있다.
  - 액션을 콘솔에 출력하거나, 서버쪽에 로깅할 수 있다.
  - 액션이 디스패치 됐을 때 이를 수정해서 리듀서에게 전달되도록 할 수 있다.
  - 특정 액션이 발생했을 때 이에 기반하여 다른 액션이 발생되도록 할 수 있다.
  - 특정 액션이 발생했을 때 자바스크립트 함수를 실행시킬 수 있다.

<br>

- 리덕스
  1. 액션 타입 정하기
  2. 액션 생성 함수 만들기 (type, payload)
  3. 리듀서 만들기
  4. 루트 리듀서 만들기

<br>

- 상태 변화 감지
  - redux-logger를 통해 상태변화를 확인할 수 있다. 단점은 console이 너무 많이 찍힐 수 있다.
  - logger를 사용하는 경우, logger가 applyMiddleware에서 가장 마지막에 와야한다.
    - `npm i redux-logger`
    - _`import_ logger _from_ "redux-logger";`
    - `const store = createStore(rootReducer, applyMiddleware(logger));`
  - devTools를 통해서도 상태변화를 확인할 수 있다.
    - `npm i redux-devtools-extension`
      ```
      const store = createStore(
        rootReducer,
        composeWithDevTools(applyMiddleware(logger))
      );
      ```
    - 버전이 바뀌어서 지금은 아래와 같이 해야된다고 함
      - `npm i @redux-devtools/extension`
      - `import { composeWithDevTools } from ‘@redux-devtools/extension’;`

<br>

- Redux-Thunk
  - 리덕스에서 비동기 작업을 처리할 때 가장 많이 사용하는 미들웨어
  - 이 미들웨어를 사용하면 액션 객체가 아닌 함수를 디스패치할 수 있다.
  - 지연된 연산을 실행하기 위해 표현식으로 만든 함수
    1. dispatch(action)이 호출되면서 스토어로 액션이 전달된다.
    2. redux-thunk 미들웨어를 거치면서 전달된 액션이 thunk 형태의 함수인지를 확인한다.
    3. 이때 thunk라면 thunk() 함수 내부에서 비동기 처리 코드를 실행하고, 이 과정에서 상태를 변경할 수 있는 액션을 전달한다.
    4. 이 함수 내부에서 비동기 처리가 시작되었음을 나타내기 위한 상태 변경 액션을 전달(dispatch)한다.
    5. 비동기 처리가 완료되면 처리 결과를 화면에 나타내기 위한 상태 변경 액션을 전달(dispatch)한다.
    6. thunk가 아니라면 next(action)을 호출해 리듀서가 새로운 상태를 만들어내도록 한다.

<br>

- 정리하자면 액션이 비동기 처리 코드를 포함한 thunk이면 thunk를 바로 호출하고 비동기 처리가 진행되는 동안 dispatch(action)로 처리 과정 중의 상태를 변경하게 된다. 일반적으로 상태 변경이 필요한 시점은 다음과 같다.
  - 작업 요청을 시작하는 시점
  - 작업이 성공적으로 완료된 시점
  - 작업이 실패한 시점
