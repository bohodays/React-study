## 06. 리액트 훅

<br>

### 6.1 함수 컴포넌트와 리액트 훅

- 리액트 16.8 버전부터 리액트 훅(react hook)이 추가됐고, 상태 관리와 주요 생명주기 이벤트 기능을 사용할 수 있게 되면서 대부분 함수 컴포넌트를 사용하고 있다.

<br>

### 6.2 useState 훅

- useState 훅은 함수 컴포넌트에서 상태를 이용하기 위해 사용하는 훅이다. useState의 기본적인 사용방법은 아래와 같다.

```javascript
// getter: 읽기 전용의 속성
// setter: 상태를 변경할 때 사용하는 함수
// StateType: 상태 데이터의 타입
// initialValue: 상태 초기값
const [getter, setter] = useState < StateType > initialValue;
```

<br>

### 6.3 useEffect 훅

- useEffect 훅은 클래스 컴포넌트의 componentDidUpdate, componentDidMount, componentWillUnmount 생명주기 메서드의 기능을 제공한다. useEffect 훅의 기본 사용법은 아래와 같다.

```javascript
// effectCallback: 필수로 작성해야 하는 함수로, 클린업 함수를 리턴할 수 있다.
// deptsList: 선택적으로 전달하는 의존 객체 배열 값
useEffect(effectCallback, [deptsList]);
```

- useEffect 훅에 effectCallback 함수만을 인자로 전달하면 컴포넌트가 마운트될 때와 컴포넌트 내부의 상태나 속성이 바뀌어 다시 렌더링될 때 effectCallback 함수가 실행된다.
- depsList는 '의존 객체의 배열'이다. depsList에 지정된 상태나 속성이 변경되면 effectCallback 함수가 호출된다. 반대로 말하자면 depsList에 지정되지 않은 상태나 속성이 변경될 때는 effectCallback이 호출되지 않는다.
- depsList 값으로 [ ]와 같이 빈 배열을 전달하면 effectCallback 함수는 컴포넌트가 마운트될 때만 실행된다.
- depsList에 빈 배열을 전달하는 것과 아무것도 전달하지 않는 것은 차이가 있으니 주의하자.
- effectCallback 함수 내부에서 클린업 함수를 리턴하도록 작성할 수도 있다. 클린업 함수는 ( ) => void 형태이며, 컴포넌트가 언마운트될 때 실행된다.

<br>

### 6.3.1 useEffect의 장점

- 클래스 컴포넌트의 componentDidMount, componentWillUnmount 생명주기 메서드는 하나씩만 작성할 수 있다. 따라서 컴포넌트 내부의 여러 상태와 관련된 로직의 코드가 모두 한 생명주기 메서드 내에 작성해야 한다. 그리고 하나의 상태와 관련된 로직이지만 컴포넌트가 마운트될 때와 언마운트될 때로 나누어 서로 다른 생명주기 메서드에 작성해야 하므로 코드를 알아보기가 불편하다.
- useEffect 훅은 위의 문제를 해결해준다. 한 컴포넌트 내부에 useEffect 훅을 여러 개를 사용할 수 있으며, 상태와 상태 관련 로직을 중심으로 useEffect 훅을 작성할 수 있어서 관련된 코드들이 함께 모여 있으므로 코드를 이해하기 편리하다.

<br>

### 6.3.2 리액트 훅의 생명주기

- 컴포넌트가 마운트될 때
  - 레이지 초기화
    - 레이지 초기화를 실행한다. 레이지 초기화는 useState( )나 useReducer에 전달하는 함수이다. 이 함수는 비동기로 지연되어 호출된다. 예를 들면 다음과 같다.
    - 일반적인 초기화: const count1 = useState<number>(0);
    - 레이지 초기화: const count2 = useState<number>(( ) => { return 0; });
    - 이 단계는 컴포넌트가 마운트될 때만 실행된다. 특히 레이지 초기화를 실행할 때 인자로 전달되는 함수 내부에서 실행되는 코드는 마운트될 때만 실행된다. 상태로 사용할 데이터를 도출하기 위해 복잡한 로직이 필요한 경우에 레이지 초기화가 유용하다.
  - 렌더링
    - 함수 컴포넌트의 내부 코드가 실행된다. 이때 가상 DOM에 대한 쓰기 작업을 수행한다.
  - 가상 DOM 업데이트
    - 가상 DOM 트리틀 업데이트한다.
  - LayoutEffects 실행
    - useLayoutEffect 훅에 지정한 함수를 실행한다.
  - 브라우저 DOM 업데이트
    - 브라우저 DOM을 업데이트한다. 이 단계가 완료되면 브라우저 화면의 갱신이 완료된 상태가 된다.
  - Effects 실행
    - useEffect 훅에 지정한 함수가 호출된다.
- 컴포넌트가 업데이트될 때
- 이 단계는 부모 컴포넌트가 다시 렌더링되거나 컴포넌트 자신의 상태, 속성이 바뀔 때 일어난다.
  - 렌더링
    - 컴포넌트가 마운트될 때와 같다.
  - 가상 DOM 업데이트
    - 컴포넌트가 마운트될 때와 같다.
  - LayoutEffect 클린업
    - useLayoutEffect 훅의 두 번째 인자(의존 객체 배열: depsList) 전달 여부에 따라 리턴한 클린업 함수가 호출된다.
  - LayoutEffects 실행
    - useLayoutEffect 훅의 두 번째 인자 전달 여부에 따라 지정한 함수를 실행한다.
  - 브라우저 DOM 업데이트
    - 컴포넌트가 마운트될 때와 같다.
  - Effects 클린업
    - useEffect 훅의 두 번째 인자 전달 여부에 따라 리턴한 클린업 함수가 호출된다.
  - Effects 실행
    - useEffect 훅의 두 번째 인자 전달 여부에 따라 지정한 함수가 실행한다.
- 컴포넌트가 언마운트될 때
  - LayoutEffects 클린업
    - useLayoutEffect 훅이 리턴하는 클린업 함수가 호출된다.
  - Effects 클린업
    - useEffect 훅이 리턴하는 클린업 함수가 호출된다.
- useLayoutEffect 훅이란?
  - LayoutEffect는 useLayoutEffect 훅에 의해 실행되는 콜백 함수다. useEffect 훅의 콜백 함수는 컴포넌트가 완전히 마운트된 상황, 즉 브라우저 DOM에서의 렌더링 작업이 완료된 후에 실행되는 반면 useLayoutEffect 훅의 콜백 함수는 컴포넌트가 렌더링되고 브라우저 DOM에서의 렌더링이 실행되기 전에 호출되며 동기적으로만 실행한다.
  - 따라서 복잡한 처리 과정이나 외부 백엔드 API를 읽어오는 등 대부분의 작업은 useEffect 훅을 사용할 것을 권장하며, 간단한 작업이면서 다시 렌더링으로 인한 화면의 깜빡임을 사용자에게 보여주고 싶지 않을 때는 useLayoutEffect 훅을 사용한다.

<br>

### 6.3.3 컴포넌트가 업데이트될 때

```javascript
useEffect(() => {
  // -------------
  // 영역 1
  // -------------

  // 클린업 함수
  return () => {
    // -------------
    // 영역 2
    // -------------
  };
}, depsList);
```

- 컴포넌트가 마운트될 때: 영역 1이 항상 실행된다.
- 컴포넌트가 언마운트될 때: 영역 2가 항상 실행된다.
- 컴포넌트가 업데이트될 때: 아래의 세 가지 경우로 나뉜다.
  - 두 번째 인자인 depsList를 전달하지 않을 때
    - 컴포넌트가 업데이트될 때마다 영역2에서 영역1 순으로 실행
  - 두 번째 인자로 빈 배열([ ])을 전달할 때
    - 영역 1, 영역 2 모두 실행되지 않음
  - 두 번째 인자로 [ dep1, dep2 ]와 같이 의존 객체 배열을 지정하여 전달할 때
    - 지정한 의존 객체(dep1 또는 dep2)가 바뀔 때만 영역2에서 영역1 순으로 실행

<br>

### 6.4 useReducer 훅

- 지금까지 상태를 변경하는 기능은 useState 훅을 호출하여 만든 setter 메서드를 이용했다. 이 방법이 가장 기본적이고 일반적이지만 복잡한 상태를 관리하고 변경할 때는 컴포넌트에 상태 변경 로직이 포함되어야 하므로 컴포넌트 내부가 복잡해진다. 이러한 경우에 useReducer 훅을 사용하면 상태와 관련된 로직을 컴포넌트 밖으로 분리시킬 수 있다. 여러 컴포넌트가 유사한 상태 관련 로직이 필요한 경우에 유용하다.
- useReducer 훅을 사용하는 방법은 다음과 같다.

```javascript
// state: 상태
// dispatch: 상태를 변경하는 메서드
// reducer: 새로운 상태를 리턴하는 리듀서 함수
// initialState: 초기 상태로 지정할 객체
const [state, dispatch] = useReducer(reducer, initialState);
```

- 단순히 상태를 관리하고 변경하는 거라면 useState 훅을 사용해도 충분하지만 useReducer를 사용하면 다음과 같은 두 가지의 장점이 있다.
  - 상태 관리 기능을 컴포넌트로부터 분리할 수 있고, 유사한 상태 관리 기능을 사용하는 여러 컴포넌트가 상태 변경과 관리 기능을 공유할 수 있다.
  - 불변성을 가지는 상태 변경을 강제하게 되므로 상태 변경을 추적하기가 용이하다.

<br>

### 6.4.1 리듀서 함수

- useReducer 훅이 사용하는 리듀서 함수는 다음과 같은 형태다. 순수 함수여야 하기 때문에 state와 action을 변경해서는 안 되고, 반드시 새로운 형태를 만들어서 리턴해야 한다.
- 리액트 애플리케이션에서는 상태가 바뀌면 UI도 갱신되므로 상태의 변경 추적이 디버깅 시에 필요한데, 리듀서를 사용하면 과거 시점의 상태가 그대로 유지되므로 언제든지 과거 시점의 상태 데이터를 확인할 수 있고 시간대별로 상태가 어떻게 변경됐는지를 추적할 수 있다.

<br>

### 6.5 useRef 훅

- useState 훅을 이용해 생성한 상태를 업데이트하면 컴포넌트가 다시 렌더링된다. 반면에 컴포넌트 내부에 직접 정의한 변수들은 컴포넌트가 다시 렌더링되면 모두 초기화되어 버린다. useRef 훅을 호출한 뒤 리턴받은 ref 객체는 컴포넌트의 모든 생명주기 동안에 유지되므로 다시 렌더링되더라도 기존 참조 데이터를 유지한다. 대신 ref 객체가 참조하는 데이터가 변경되더라도 다시 렌더링이 일어나지는 않는다. 또한 useRef를 이용하면서 동시에 브라우저 DOM 요소의 태그에서 ref 특성을 사용하면 브라우저 DOM의 요소에 직접 접근할 수 있다.
- useRef 훅의 리턴값은 값에 대한 참조를 포함하는 객체이다. 참조 데이터에 접근하려면 반드시 `.current` 속성을 사용해야 하는 점에 주의해야 한다. useRef 훅을 사용하는 방법은 다음과 같다.

```javascript
// initialValue: 참조 객체로 주어질 초기값;
const refObject = useRef(initialValue);
```

<br>

### 6.6 메모이제이션 훅

- 메모이제이션(memoization)이란 기존에 연산된 결과값을 메모리에 캐싱하고, 동일한 입력과 환경에서 재사용하는 기법을 말한다. 이 기법을 적절히 사용하면 중복 처리를 피할 수 있어서 애플리케이션의 성능을 최적화할 때 종종 사용한다. 메모이제이션 기능을 제공하는 리액트 훅은 useMemo와 useCallback으로 두 가지가 있다.
  - useMemo
    - useMemo는 함수가 호출되고 연산된 리턴값을 캐싱하여 재사용한다. 캐싱되는 것은 함수를 호출한 후의 리턴값이다.
  - useCallback
    - useCallback은 컴포넌트 내부의 함수를 캐싱하고, 렌더링할 때마다 함수가 생성되지 않게 재사용한다. 캐싱되는 것은 컴포넌트 내부의 함수다.

<br>

### 6.6.1 useMemo 훅 적용

- useMemo의 사용법은 다음과 같다.

```javascript
// factory : 캐싱할 값을 만들어내는 함수이다.
// depsList : 의존 객체 배열로, 이 배열의 값이 바뀌기 전까지는 캐시를 유지한다.
// 캐싱할 값은 제네릭으로 T에 타입을 지정한다.
const memoizedValue = useMemo<T>(factory: () => T, depsList);
```

- 여기서 중요한 것은 depsList 의존 객체 배열입니다. 이 배열에 지정된 값이 바뀌기 전까지는 캐시를 유지한다.

<br>

### 6.6.2 useCallback 훅 적용

- useCallback 훅은 컴포넌트 내부의 함수를 캐싱하여 다시 렌더링되더라도 함수를 매번 생성하지 않도록 해준다. useMemo 훅의 캐싱 대상이 함수의 리턴값이라면 useCallback 훅은 캐싱 대상이 컴포넌트 내부의 함수인 것이다. useCallback 훅의 사용 방법은 다음과 같다.

```javascript
// callback : 캐싱하려는 대상 함수이다.
// depsList : 함수를 캐싱할 때 의존 객체 배열이다. 이 배열의 값에 변화가 없으면 함수를 새로 만들지 않는다.
const memoizedCallback = useCallback(callback, depsList);
```

- 한 가지 주의할 점은 useCallback의 두 번째 인자인 의존 객체 배열을 적절하게 지정해야 한다는 점이다. 왜냐하면 useCallback 훅에 의해 캐싱된 함수는 함수가 생성될 때의 상태나 속성을 참조하기 때문이다.

<br>

### 6.7 사용자 정의 훅

- 사용자 정의 훅(custom hook)은 개발자가 직접 작성하는 리액트 훅이다. 여러 컴포넌트에서 필요로 하는 코드와 기능을 재사용하기 위해 사용자 정의 훅을 작성할 수 있다.
