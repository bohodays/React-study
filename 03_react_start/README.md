## 03. 리액트 시작하기

<br>

### 3.1.1 CRA 도구

- CRA(Create-React-App)는 별도의 설정 없이도 SPA 리액트 애플리케이션을 개발할 수 있도록 지원하는 공식 도구이다. 리액트 프로젝트를 진행할 때 필요한 webpack 설정을 자동화하여 개발 환경을 구축한다.

        npx create-react-app [프로젝트명]
        npx create-react-app [프로젝트명] --template typescript

- src : 자바스크립트와 타입스크립트 코드를 작성하는 디렉터리다. 진입 파일은 index.js 또는 index.ts이다.
- publick : 정적 파일과 리소스를 이 곳에 배치한다.
- bulid : 빌드 후 생성된 산출물이 저장되는 디렉터리다. 이 곳에 생성된 파일을 웹 서버에 배포할 수 있다.

<br>

### 3.1.2 Vite 도구

- Vite(비트)는 프랑스어로 '빠르다'라는 뜻을 가진 단어로, 차세대 프론트엔드 개발 도구이다. 이름처럼 빌드와 개발 서버 구동시간이 매우 빠르다. 기존 webpack과 같은 모듈 번들러를 이용할 때는 모듈 번들링을 끝낸 후 개발 서버를 구동하므로 시간이 오래 걸렸다. 이와 같은 문제점을 Vite는 Native ESM이라는 브라우저의 자체적인 모듈 기능을 사용하여 해결했다. Vite가 실행하는 개발 서버는 브라우저가 요청하는 모듈을 전송해주고, 모듈 번들링 기능을 브라우저가 수행하기 때문에 개발 서버의 구동이 매우 빠르다.

npm init vite [프로젝트명] -- --template react
npm init vite [프로젝트명] -- --template react-ts

- src : 자바스크립트와 타입스크립트 코드를 작성하는 디렉터리다. 진입 파일은 main.jsx 또는 main.tsx이다.
- publick : 정적 파일과 리소스를 이 곳에 배치한다. 자동으로 만들어지지 않으므로 직접 생성해야 한다.
- dist : 빌드 후 생성된 산출물이 저장되는 디렉터리다.

<br>

### 3.2 Hello 애플리케이션 작성

- 저장을 하면 웹 브라우저 화면이 자동으로 갱신되는 것을 HMR(Hot Module Replacement)라고 부르는데, 개발 서버가 실행 중인 상태에서도 코드를 수정하면 웹 브라우저는 변경된 모듈을 개발 서버로부터 다운로드해서 화면을 즉시 갱신한다.
- Vite 프로젝트에서 절대 경로 사용하는 방법 (p.82)

<br>

### 3.3 CSS 스타일 적용 방법

- bootstrap 적용 방법

        npm i bootstrap
        import 'bootstrap/dist/css/bootstrap.css'

<br>

### 3.4 JSX

- JSX(JavaScript XML)는 HTML처럼 보이지만 실제로는 자바스크립트 확장이다. 즉, 자바스크립트 코드로 변환되어 실행된다. JSX의 사용이 필수는 아니지만 JSX는 UI를 표현하는데 적바해서 웹 디자이너나 웹 퍼블리셔들과 협업하기 편리하다. 그리고 JSX는 자바스크립트 코드이므로 자바스크립트 언어라는 의미가 변형되지 않으면서도 애플리케이션 화면의 구조를 시각화하여 표현할 수 있다.

<br>

### 3.4.1 JSX 주의사항 1

- `요소의 Attribute는 카멜 표기법(camel casing)을 준수해야 한다.`
- 자바스크립트 코드에서는 onclick처럼 이벤트를 모두 소문자로 작성하지만 리액트에서는 onClick과 같이 새로운 단어가 연결되면 첫 글자를 대문자로 표기한다.

<br>

### 3.4.2 JSX 주의사항 2

- `속성명이 DOM API 스펙에 기반을 두고 있다.`

```javascript
// HTML에서의 CSS 클래스 지정
<div id="a" class="test "></div>;

// JavaScript 코드에서의 CSS 지정
document.getElementById("a").className = "test";

// JSX에서의 정적 CSS 클래스 지정
<div id="a" className="test"></div>;

// JSX에서의 동적 CSS 클래스 지정
let className = "test";
<div id="a" className={className}></div>;
```

- JSX는 HTML처럼 보이지만 실제로는 자바스크립트 코드이기 때문에 className 속성으로 사용해야만 한다.

<br>

### 3.4.3 JSX 주의사항 3

- `보간법({} : interpolation)을 사용할 때는 표현식을 사용해야 한다.`
- { }는 무엇인가 데이터를 UI로 렌더링하려는 것이 목적이므로 반드시 값(데이터)이 있어야 한다. 예를 들어 if문은 리턴값이 없으므로 사용할 수 없다. 대신에 삼항 연산식은 리턴값이 있으므로 사용할 수 있다.

<br>

### 3.4.4 JSX 주의사항 4

- `{ }내에 보간된 HTML 문자열은 인코딩된다.`

        let msg = "<i>World!</i>";
        화면에 <i>World!</i>로 보임

- HTML 마크업 형태의 값을 보간하려고 하면 다음과 같이 사용하면 된다.

        let msg = (<i>World!</i>);

<br>

### 3.4.5 JSX 주의사항 5

- `JSX는 단일 루트 요소만 렌더링할 수 있다.`
- JSX 코드에서 반드시 루트 요소는 하나만 작성해야 한다. <> </>ㅇ와 같이 시작 태그와 마감 태그에 태그명이 없는 형식으로 JSX 구문을 작성하면 된다.

```typescript
return (
  <>
    <div>Hello</div>
    <div>World</div>
  </>
);
```

<br>

### 3.5.1 속성

- 속성(props)을 이용하면 상위 컴포넌트(부모 컴포넌트)로부터 데이터를 전달받도록 작성할 수 있다. `단, 데이터는 부모에서 자식으로만 전달할 수 있다.`
- `자식 컴포넌트에서는 부모 컴포넌트로부터 전달받은 정보를 변경할 수 없다.`
- 만일 여러 자식 컴포넌트에서 데이터가 변경되면 데이터가 어디서 어떻게 변경되는지 추적하기가 어렵다.
- 리액트는 데이터가 바뀌면 UI가 갱신되도록 설게되어 있다. 따라서 디버깅을 할 때 중점적으로 살펴봐야 할 것은 바로 데이터가 어떻게 변경되느냐이다.
- 부모 컴포넌트에서 자식 컴포넌트로 속성을 전달할 때는 보간법을 활용한다.

```typescript
<Test name={yourName} age={yourAge} />
```

<br>

### 3.5.2 컴포넌트의 세분화

- 컴포넌트 세분화의 장점
  - 컴포넌트의 기능이 단순해지기 때문에 에러가 발생할 가능성이 줄어들며 디버깅과 테스트가 쉬워진다.
  - 컴포넌트의 재사용성이 높아진다.
  - 렌더링 성능을 최적하기가 더 용이하다.
    - 리액트에서의 렌더링이란?
      - 사용자의 화면에 뷰(View)를 보여주기 리액트 컴포넌트가 HTML 요소를 그려내는 작업을 의미한다. 브라우저 DOM에 직접 렌더링하면 많은 리소스가 필요해서 리액트는 브라우저 DOM에 직접 렌더링하지 않고 가상 DOM에 렌더링한다. 그 다음 이전 렌더링 결과와 현재 렌더링 결과를 비교해서 차이가 나는 부분만 브라우저 DOM에 업데이트하여 렌더링 성능을 높인다.

<br>

### 3.5.3 상태

- 상태(state)는 컴포넌트가 보유하고 관리하는 데이터다. 상태의 변경은 상태를 보유한 컴포넌트에서만 수행한다. 특히 상태를 속성으로 자식 컴포넌트에 전달할 경우, 자식 컴포넌트에서 그 속성을 변경해서는 안된다.
- 무상태 컴포넌트의 재사용성은 상태 컴포넌트보다 뛰어나다.
- 모든 컴포넌트가 상태가 필요한가
  - 모든 컴포넌트에 상태를 정의할 수 있지만 권장하지는 않는다. 상태는 리액트 애플리케이션에서 추적이 필요한 아주 중요한 데이터이다. 모든 컴포넌트가 상태를 가지면 상태 변경을 추적해야 할 지점이 많아지기 때문에 오히려 관리와 디버깅이 어려워진다.
